type vector = {
    x: number,
    y: number,
    z: number,
}

local privateKey = require("./privateKey")

-- local math = require('./math')
local abs = math.abs
local atan2 = math.atan2
local ceil = math.ceil
local clamp = math.clamp
local floor = math.floor
local sign = math.sign

--[=[
TODO: Add type checking && privatekey

if not vec[privateKey] then
    return
end
]=]

local function vector_create(x: number, y: number, z: number): vector
    return setmetatable({ 
        [privateKey] = {
            x=x, 
            y=y, 
            z=z,
        },
    }, {
        __newindex = function(_, key)
            error(`attempt to index vector with '{key}'`)
        end,
        __tostring = function(self)
            self = self[privateKey] :: vector
            return `{self.x}, {self.y}, {self.z}`
        end,
    }) :: any
end

-- print(vector.create(1, 2, 3))
-- print(vector_create(1, 2, 3))

local function vector_magnitude(vec: vector)
    vec = vec[privateKey]
    return (vec.x * vec.x + vec.y * vec.y + vec.z * vec.z) ^ 0.5
end

-- print(math.round(vector.magnitude(vector.create(10, 5, 5)) * 1000) / 1000)
-- print(math.round(vector_magnitude(vector_create(10, 5, 5)) * 1000) / 1000)

local function vector_normalize(vec: vector)
    vec = vec[privateKey]
    local invSqrt = 1 / ((vec.x * vec.x + vec.y * vec.y + vec.z * vec.z) ^ 0.5)
    return vector_create(vec.x * invSqrt, vec.y * invSqrt, vec.z * invSqrt)
end

-- print(vector.normalize(vector.create(10, 5, 5)))
-- print(vector_normalize(vector_create(10, 5, 5)))

local function vector_cross(vec1: vector, vec2: vector)
    vec1 = vec1[privateKey]
    vec2 = vec2[privateKey]
    return vector_create(vec1.y * vec2.z - vec1.z * vec2.y, vec1.z * vec2.x - vec1.x * vec2.z, vec1.x * vec2.y - vec1.y * vec2.x)
end

-- print(vector.cross(vector.create(10, 5, 5), vector.create(5, 5, 10)))
-- print(vector_cross(vector_create(10, 5, 5), vector_create(5, 5, 10)))

local function vector_dot(vec1: vector, vec2: vector)
    vec1 = vec1[privateKey]
    vec2 = vec2[privateKey]
    return (vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z)
end

-- print(vector.dot(vector.create(10, 5, 5), vector.create(5, 5, 10)))
-- print(vector_dot(vector_create(10, 5, 5), vector_create(5, 5, 10)))

local function vector_angle(vec1: vector, vec2: vector, axis: vector?)
    vec1 = vec1[privateKey]
    vec2 = vec2[privateKey]
    local cross = { vec1.y * vec2.z - vec1.z * vec2.y, vec1.z * vec2.x - vec1.x * vec2.z, vec1.x * vec2.y - vec1.y * vec2.x }

    local sin_vec1 = (cross[1]^2 + cross[2]^2 + cross[3] ^2) ^ 0.5
    local cos_vec1 = vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z
    local angle = atan2(sin_vec1, cos_vec1)

    if axis then
        axis = axis[privateKey]
        if (cross[1] * axis.x + cross[2] * axis.y + cross[3] * axis.z) < 0 then
            angle = -angle
        end
    end

    return angle
end

-- print(vector.angle(vector.create(10, 5, 5), vector.create(5, 5, 10), vector.create(10, 5, 5)))
-- print(vector_angle(vector_create(10, 5, 5), vector_create(5, 5, 10), vector_create(10, 5, 5)))

local function vector_floor(vec: vector)
    vec = vec[privateKey]
    return vector_create(floor(vec.x), floor(vec.y), floor(vec.z))
end

-- print(vector.floor(vector.create(10.123, 20.234, 30.345)))
-- print(vector_floor(vector_create(10.123, 20.234, 30.345)))

local function vector_ceil(vec: vector)
    vec = vec[privateKey]
    return vector_create(ceil(vec.x), ceil(vec.y), ceil(vec.z))
end

-- print(vector.ceil(vector.create(10.01, 20.222, 30.0001)))
-- print(vector_ceil(vector_create(10.01, 20.222, 30.0001)))

local function vector_abs(vec: vector)
    vec = vec[privateKey]
    return vector_create(abs(vec.x), abs(vec.y), abs(vec.z))
end

-- print(vector.abs(vector.create(-10.01, 20.222, -30.0001)))
-- print(vector_abs(vector_create(-10.01, 20.222, -30.0001)))

local function vector_sign(vec: vector)
    vec = vec[privateKey]
    return vector_create(sign(vec.x), sign(vec.y), sign(vec.z))
end

-- print(vector.sign(vector.create(-10, 20, -30)))
-- print(vector_sign(vector_create(-10, 20, -30)))

local function vector_clamp(vec: vector, min: vector, max: vector)
    vec = vec[privateKey]
    min = min[privateKey]
    max = max[privateKey]

    for k, v in min do
        if not ((v :: number) > max[k]) then
            continue
        end
        error(`invalid argument #3 to 'clamp' (max.{k} must be greater than or equal to min.{k})`)
    end

    return vector_create(clamp(vec.x, min.x, max.x), clamp(vec.y, min.y, max.y), clamp(vec.z, min.z, max.z))
end

-- print(vector.clamp(vector.create(10, -10, 50), vector.create(1, 1, 1), vector.create(5, 100, 100)))
-- print(vector_clamp(vector_create(10, -10, 50), vector_create(1, 1, 1), vector_create(5, 100, 100)))

local function vector_min(vector: vector, ...: vector)
    vector = vector[privateKey]
    local result = { vector.x, vector.y, vector.z }
    local args = { ... }

    for i=1, #args do
        local vec: vector = args[i][privateKey]
        if vec.x < result[1] then
           result[1] = vec.x    
        end
        if vec.y < result[2] then
            result[2] = vec.y    
        end
        if vec.z < result[3] then
           result[3] = vec.z    
        end
    end

    return vector_create(result[1], result[2], result[3])
end

-- print(vector.min(vector.create(100, 100, 100), vector.create(1, 100, 100), vector.create(100, 2, 100), vector.create(100, 100, 3), vector.one))
-- print(vector_min(vector_create(100, 100, 100), vector_create(1, 100, 100), vector_create(100, 2, 100), vector_create(100, 100, 3), vector_create(1, 1, 1)))

local function vector_max(vector: vector, ...: vector)
    vector = vector[privateKey]
    local result = { vector.x, vector.y, vector.z }
    local args = { ... }

    for i=1, #args do
        local vec: vector = args[i][privateKey]
        if vec.x > result[1] then
           result[1] = vec.x    
        end
        if vec.y > result[2] then
            result[2] = vec.y    
        end
        if vec.z > result[3] then
           result[3] = vec.z    
        end
    end

    return vector_create(result[1], result[2], result[3])
end

-- print(vector.min(vector.create(-100, -100, -100), vector.create(1, 100, 100), vector.create(100, 2, 100), vector.create(100, 100, 3), vector.one))
-- print(vector_min(vector_create(-100, -100, -100), vector_create(1, 100, 100), vector_create(100, 2, 100), vector_create(100, 100, 3), vector_create(1, 1, 1)))

local vector_zero = vector_create(0, 0, 0)
local vector_one: vector = vector_create(1, 1, 1)

-- print(vector.zero, vector.one)
-- print(vector_zero, vector_one)

return {
    abs = vector_abs,    
    angle = vector_angle,
    ceil = vector_ceil,
    clamp = vector_clamp,
    create = vector_create,
    cross = vector_cross,
    dot = vector_dot,
    floor = vector_floor,
    magnitude = vector_magnitude,
    max = vector_max,
    min = vector_min,
    normalize = vector_normalize,
    sign = vector_sign,

    zero = vector_zero,
    one = vector_one,
}